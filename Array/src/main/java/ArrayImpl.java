package com.company;

import java.util.Arrays;

public class ArrayImpl <E extends Comparable<? super E>> implements Array<E> {

    private static final int DEFAULT_CAPACITY = 8; // ЁМКОСТЬ ПО УМОЛЧАНИЮ МАССИВА

    protected E[] data; // имя/data - это хранилище, где будут храниться элементы
    protected int size; // размер/size - это текущие состояние элементов в хранилище (изначальное состояние равно 0, так как мы имеем пустой массив)


    public ArrayImpl() {            // Параметризованный конструктор;
        this(DEFAULT_CAPACITY);     // то есть бы просили значение DEFAULT_CAPACITY в скобки (), потому-что this() вызывает весь конструктор ниже ArrayImpl(int initialCapacity)
    }

    @SuppressWarnings("unchecked") // unchecked/непроверенный - Тип аннотации @SuppressWarnings позволяет программистам Java отключать предупреждения о компиляции для определенной части программы (тип, поле, метод, параметр, конструктор и локальная переменная). Обычно предупреждения-это хорошо. То есть это заглушка для этой ситуации
    public ArrayImpl(int initialCapacity) { // Конструктор: начальная int initialCapacity[начальная ёмкость массива]
        this.data = (E[]) new Comparable[initialCapacity];  // new Comparable[initialCapacity] - это создание нового массива и приравняли его к Обобщению (E[])
    }


    // O(1) -> O(n)
    @Override // переопределили метод из interface Array метода add(добавление)
    public void add(E value) { // + метод add(добавление) - это добавление элементов в нашу коллекцию друг за другом
        checkAndGrow(); // вызвали тут метод checkAndGrow/проверь и вырасти
        data[size++] = value;    // (Более короткая форма написания 1.1) У нас size содержит 0 значение индекса и мы добавляем в него value-значение, после этого (как добавили в индекс значение), оно у нас увеличивается (size++) -> size = 1 + size, чтобы следующие значение добавилось в следующий индекс (то есть size у нас хранит, то значение индекса которое нам необходимо)
        // data[size] = value;   // (Более длинная форма написания 2.1) У нас size содержит 0 значение индекса и мы добавляем в него value-значение
        // size++;               // (Более длинная форма написания 2.2), после этого (как добавили в индекс значение) оно у нас увеличивается (size++) -> size = 1 + size, чтобы следующие значение добавилось в следующий индекс ("size" выполняет две функции: 1-ое: То есть size у нас хранит, то значение индекса которое нам необходимо, при новым вызове "add" и 2-ое: Количество элементов, которое мы храним).
    }

    // O(n)
    @Override // переопределили метод из interface Array метода insert(вставлять)
    public void insert(E value, int index) { // + метод insert(вставки (элемента в массив))
        checkAndGrow(); // вызвали тут метод checkAndGrow/проверь и вырасти
        if (index == size) { // 1.1 Если индекс(index) равен(==) размеру массива(size)
            add(value);      // 1.2 , то мы вызываем метод add() и вставляем значение "value" и получается: add(value)
        } else {
            checkIndex(index); // 2.1 метод checkIndex() - это метод проверки (индекса), то есть суть этого метода, чтобы индекс был Валидным
        // ТУТ НУЖНО СМЕСТИТЬ ЭЛЕМЕНТЫ НА ОДНУ ПОЗИЦИЮ В МАССИВЕ В ПРАВО [1][2][3][4]
        // ЧТОБЫ У НАС ПОЛУЧИЛОСЬ ВОТ ТАК: [1][2][x][3][4]
        // (Это более длинный вариант: 3.1, 3.2, 3.3 )
        //    for (int i = size - 1; i >= index; i--) { // 3.1  1) Если мы говорим size - 1 мы сдвигаем в право на один элемент и переносим всё в i (int i); 2) Когда доходим до нашего индекса i >= index; 3)
        //        data[i + 1] = data[i]; // 3.2 передали наш data[i] в data[i + 1]
        //    } // 3.3
        // (Это более короткий вариант: +3.1 ,+3.2, +3.3 )
            if (size - index >= 0) { // +3.1
               System.arraycopy(data, index, data, index +1, size-index); // +3.2
           } // +3.3
           data[index] = value; // 4.1 Когда всё сделали data[index] равняется(=) новому значение(value), то есть мы туда его перенесли
            size++; // 4.2 увеличили размер
        }
    }


    // O(1)
    @Override // переопределили метод из interface Array метода get(который возвращает нам значение)
    public E get(int index) { // + метод get(который возвращает нам значение) - этот метод получает наши объекты по некоторому индексу(index), то есть когда мы хотим обратиться к нашему массиву по индексу
        checkIndex(index);  // (подведи на метод и нажми "ctrl") метод checkIndex это метод проверки (индекса), то есть суть этого метода, чтобы индекс был Валидным
        return data[index]; // то есть, когда мы хотим обратиться к нашему массиву по индексу
    }

    // O(n)
    @Override // переопределили метод из interface Array метода remove(удаляет) ответ true(Да), если удалил; и false(Нет), если не удалил
    public boolean remove(E value) {  // + remove(удаляет) Тут в этом методе remove(удаляет) хотим удалять наши элементы, какое-то определённое значение(value). Ответ true(Да), если такой элемент value был и удалился; и false(Нет), если, такого элемента value не было и он не удалился.
        int index = indexOf(value); // метод indexOf(возвращает индекс), и передаём туда value(значение), и получается у нас: indexOf(value) и передаём всё в int index - это позиция удаляемого элемента его индекс
        return index != -1 && (remove(index) != null); // Возвращаем индекс(index) если не равняется(!=) -1 и считаем, что такой элемент удалился и возвращаем true И(&&) Возвращаем remove(индекс) если не равняется(!=) налу(null) и считаем, что такой элемент удалился и возвращаем true
        // Если тут: TRUE   &&  и тут: TRUE  = всё выражение TRUE  (эти два выражения: index != -1 && (remove(index) != null); работают, только вместе, согласно &&)
        // Если тут: FALSE  &&  и тут: FALSE = всё выражение FALSE (эти два выражения: index != -1 && (remove(index) != null); работают, только вместе, согласно &&)
        // Если тут: FALSE  &&  и тут: TRUE  = всё выражение FALSE (эти два выражения: index != -1 && (remove(index) != null); работают, только вместе, согласно &&)
        // Если тут: TRUE   &&  и тут: FALSE = всё выражение FALSE (эти два выражения: index != -1 && (remove(index) != null); работают, только вместе, согласно &&)
    }

    @Override // переопределили метод из interface Array метода remove(удаляет)
    public E remove(int index) { // + метод remove(удаляет) по определённой позиции(index), тут будет возвращать тот объект, который удалили
        checkIndex(index); // Это метод проверки (индекса), то есть суть этого метода, чтобы индекс был Валидным
        E removedValue = data[index]; // Пишем индекс "data[index]", который хотим удалить и переносим его в removedValue(то есть тут мы его получили)
        if (size - 1 - index >= 0) {
        // 1.1 if (int i = index; i < size - 1; i++) { // (int i = index) индекс значение мы передаём в i, если i(индекс) меньше размера - 1 массива(size -1), и делаем это до конца массива i++
        // 1.2 СДВИГАЕМ НА ОДНУ ПОЗИЦИЮ В ПРАВО
        // 1.2 data[i] = data[i + 1]; // тут i позиция нашего удаляемого элемента, присваиваем на одну позицию в право, то есть "+1" data[i + 1] и передаём всё "=" в data[i] в эту позицию, которая была пуста
            System.arraycopy(data, index + 1, data, index, size - 1 - index);
        }

        data[size - 1] = null; // 1.3.1 Если в последней позиции был какой-то тяжёлый объект после передвижения 1,2,4,5,(5) - мы ссылку тут разрываем (5) и если ссылки не ведут на этот объект, то сборщик мусора её удалит
        size--;                // 1.3.2 и убираем одну не нужную позицию
        return removedValue;   // 1.4 И возвращаем наше удаляемое значение
    }

    // O(n)
    @Override // переопределили метод из interface Array метода indexOf(возвращает индекс)
    public int indexOf(E value) { // + метод indexOf(возвращает индекс) возвращает индекс в данной строке первого вхождения указанного символа или -1, если символ не встречается.
        for (int i = 0; i < size; i++) { // 1.1) Бежим по циклу (size-размер)
            if (data[i].equals(value)) { // 1.2) Если то значение, которое имеется(data[i]) равно тому значению, которое мы ищем(value-значение)
                //return i; // 1.3) ЕСЛИ ОТВЕТ от "1.2)" = ДА, то: тогда возвращаем значение нашего индекса i
            }
        }
        return -1; // 1.4) ЕСЛИ ОТВЕТ от "1.2)" = НЕТ, то: возвращаем от туда -1
    }

    @Override // переопределили метод из interface Array метода size(размер)
    public int size() { // + метод size(размер), этот метод говорит актуальное количество элементов, которые сейчас в массиве(в коллекции)
        return size;
    }

    @Override // переопределили метод из interface Array метода display(отображать)
    public void display() { // + метод display(отображать) этот метод печатает в консоль состояние непосредственно нашего массива
        System.out.println(toString()); // вставили в скобки метод toString() вызвали его.
    }

    @Override // переопределили метод из interface Array от метода toString(который показывает нормально текст)
    public String toString() { // + метод toString(который показывает нормальный текст)
        StringBuilder sb = new StringBuilder("["); // 1.1 Сначала StringBuilder принимает, какое-то изначальное значение в этом случае это в скобках "["
        for (int i = 0; i < size - 1; i++) {       // 1.2 Чтобы в конце не было ", " мы делаем size - 1
            sb.append(data[i]);                    // 1.3 Для примера это числа [5, 4, 3, 2, 1]
            sb.append(", ");                       // 1.4 Для примера это запятая [5, 4, 3, 2, 1] между числами ", "
        }
        if (size > 0) { // 2.1 если размер больше 0
            //sb.append(data[size - 1]); // 2.2 тогда делаем это условие размер(size) - 1 позицию
        }
        sb.append("]"); // 3.1
        return sb.toString(); // 3.2
    }

    private void checkIndex(int index) { // + метод checkIndex это метод проверки (индекса), то есть суть этого метода, чтобы индекс был Валидным
        if (index < 0 || index >= size) { // 1.1 Если индекс(index) < 0   ИЛИ(||)  индекс(index) >= размеру(size)
            throw new MyCustomArrayIndexOutOfBoundsException(index, size); // 1.2 То если по выражению "1.1" подошло, то бросает это выражение об ошибки MyCustomArrayIndexOutOfBoundsException(index, size)
        }
    }

    protected void checkAndGrow() { // + метод checkAndGrow(проверь и вырасти)
        if (data.length == size) {  // Если длина всего массива "data" равна размеру(элементов)
            data = Arrays.copyOf(data, calculateNewLength()); // То выполняется это: Arrays. copyOf ("data" - это наш массив (который сейчас), длина нашего нового массива); Этот метод не меняет существующий массив, вместо этого, он создает новый массив и копирует в него элементы старого массива. Если элементы не поместились (длина меньше длины существующего массива), то лишние значения игнорируются. Если длина нового массива больше длины старого, ячейки заполняются нулями.
        }
    }

    private int calculateNewLength() { // + метод calculateNewLength(рассчитать новую длину массива)
        return size > 0 ? size * 2 : 1; // return(возвращаем): ЕСЛИ размер(size) > 0, (то размер(size) * 2), ЕСЛИ размер(size) меньше нуля, (то оставляем также(1))
    }

    @Override // переопределили метод из interface Array от метода trimToSize()
     public void trimToSize() { // + метод trimToSize - используется в Java для уменьшения ёмкости списка до количества элементов в нём.
        data = Arrays.copyOf(data, size); // Arrays.copyOf() — это метод в Java, который применяется, когда необходимо скопировать элементы массива, начиная с нулевого индекса.
    }
}
